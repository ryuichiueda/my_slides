# ロボットシステム学

## 第6回: ソフトウェアのテスト

千葉工業大学 上田 隆一

<br />

<p style="font-size:50%">
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
</p>

---

## 今日やること

* コマンドの終了ステータス
* シェル（bash）の変数
* テストコマンド
* 簡単なシェルスクリプト
* シェルの関数
* 初歩的なテスト

---

## 1. コマンドの終了ステータス

---

### コマンドの正常終了・異常終了

* コマンドは人に対してだけでなく，<br />シェルにエラーの有無を伝達
    * <span style="color:red">終了ステータス</span>と呼ばれる整数値で
* シェルはコマンドの終了ステータスを記録
    * <span style="color:red">`$?`</span>という変数に
    * 例: `ls`の出力
        ```bash
$ ls /etc/passwd   # 存在するファイルをls
/etc/passwd
$ echo $?
0                  # $?という変数にゼロが入っている．
$ ls aaaaaaaa      # 存在しないファイルをls
ls: 'aaaaaaaa' にアクセスできません: そのようなファイルやディレクトリはありません
$ echo $?
2                  # ゼロでない値が入る．
        ```

---

### `plus_stdin`の終了ステータス

* これまで書いてきた`plus_stdin`も終了ステータスを<br />シェルに伝達
    * Pythonが裏でやっているので，任せておいて問題ない
    ```bash
$ seq 3 | ./plus_stdin    # 正常な入力
6
$ echo $?
0
$ echo あ | ./plus_stdin  # ひらがなを入力してエラーを起こさせる
（エラーの表示．省略．）
$ echo $?
1
    ```

なんのために終了ステータスがあるか: あとで説明

---

## 2. シェルの変数

---

### 基本事項

* シェルは，`変数名=文字列`で，文字を記憶
* `${変数名}`で値に置換
    * 例:
    ```bash
    $ X=我々は宇宙人だ   # 変数のセット
    $ echo ${X}ぜ！      # 変数を値に
    我々は宇宙人だぜ！
    $ echo $X            # {}は省略できる（こともある）
    我々は宇宙人だ
    $ echo '$X' # 値にしないときはシングルクォートで囲う（``と混同注意）
    $X
    ```
    * `{}`が省略できない例:
    ```bash
    $ echo ${X}Z
    我々は宇宙人だZ
    $ echo $XZ
                         #変数「XZ」と解釈されるのでなにも出力されない
    ```

---

### コマンドの出力を変数に

* `変数名=$(コマンド)`
    * 通常は標準出力に出るコマンドの出力を<br />文字列として変数に格納
    * 例: `ls`の出力を変数`A`に　　　　　　　　　　　　　　
    ```bash
    $ A=$(ls)
    $ echo $A
    README.md plus_stdin  # 注意: 出力は各自異なります．
    ```

---

## 3. テストコマンド

* 以下のいずれかで，文字列を比較可能
    * その1: `test 比較したい文字列 = 比較したい文字列`
    * その2: `[ 比較したい文字列 = 比較したい文字列 ]`
    * その3: `[[ 比較したい文字列 = 比較したい文字列 ]]`
        * 例（その1〜3の違いには細かい話はありますが，<br />　　ここでは「その2」だけ）
        ```bash
        $ a=山田
        $ [ "$a" = 上田 ]       # [ はコマンドなので，引数はくっつけないようにしましょう．
        $ echo $?               #終了ステータスで確認
        1
	$ [ "$a" = 山田 ]
        $ echo $?
        0
        ```

---

## 4. 簡単なシェルスクリプト

* 今の比較をファイルに保存して実行してみましょう
    * 「`yamada.bash`」というファイルに，次のように記述
        ```bash
        #!/bin/bash
        
        a=山田
        [ "$a" = 上田 ]       
        echo $?               
        [ "$a" = 山田 ]
        echo $?
        ```
    * 実行
        * `chmod`してPythonのスクリプトと同様に実行
        ```bash
        $ chmod +x yamada.bash
        $ ./yamada.bash
        1
        0
        ```


---

## 5. シェルの関数

* 名前のうしろに`()`をつけて，`{}`の中に処理を記述
    * シェルスクリプト中でコマンドのように利用
    * 第`n`引数を`${n}`で受け取り（実はシェルスクリプトも同じ）
    * 例: `ng`という関数を作り，テストコマンドの失敗で呼び出し
        * `||`（OR記号）は左側のコマンドが異常終了したら右側を実行
        ```bash
	#!/bin/bash

        ng () {
        	echo ${1}行目が違うよ   #$1はngの1番目の引数
        	ret=1                   #最後に返す終了ステータスをセット
        }
        
        ret=0
        a=山田
        [ "$a" = 上田 ] || ng "$LINENO"  # LINENOは，この行の行番号の入る変数
        [ "$a" = 山田 ] || ng "$LINENO"  # ngに第一引数として$LINENOを付与
        
        exit $ret     # このシェルスクリプトの終了ステータスを返して終了
        ```

---

### 実行結果

```bash
$ ./yamada.bash
10行目が違うよ
$ echo $?
1
```

---

## 6. 初歩的なテスト

やっと本題

---

### ここで言うテストとは

* プログラムが意図通りに動作するかを<span style="color:red">別のプログラムを書いて</span>テストすること
    * 「別のプログラム」の流れ
        1. 関数やプログラムに引数で，あるいは標準入力からデータを入力
        2. 出力を記録
        3. 期待した出力と一致するか比較<br />　

面倒だと思いますか❓

---

### テストがないと辛い

* 例: 「プログラムに機能をどんどん追加していったら，<br />　　最初に書いた部分がうまく動かなくなった！」<br />
    * <span style="color:red">→こまめにテストを実行してたら早期発見していた．</span>
    * こういう目的のテストを特に<br /><span style="color:red">「リグレッションテスト（退行テスト）」</span>と言う．<br />これからそれをやる．<br />　
* 例: コードがどんな出力をすべきなのか忘却
    * テストがあると手軽に判明
    * 例えば範囲の条件が「○○未満」なのか「○○以下」なのかなどは忘れやすいし，境界条件のテストとして記述しておくとよい

---

### こういう開発スタイルに<br />早く移行しましょう

1. こまめにテスト
2. テストに通ったらGitにコミット
3. テストに失敗して，原因不明なら前回のコミットに退却
    * `git restore`
4. さらに細かくテスト

予告: 最初の課題ではこのような経緯の分かる<br />リポジトリを各自提出してもらいます！<br />（あとから慌てても無理．コピー不可能）

---

### リグレッションテストの書き方

* テストの流れ
    1. テスト対象の関数やプログラム（コマンド）に何か入力
        * 今回は標準入力を使って`plus_stdin`をテスト
    2. 出力を，あらかじめ期待していたものと比較
    3. <span style="color:red">比較の結果違っていたら，異常終了</span><br />　
        * 異常終了 = 終了ステータス非ゼロ<br />　
* テストの道具
    * 一般には，使う言語のテスト機能やライブラリを利用
    * 今回はシェルスクリプトを利用
        * 理由: 
            * 簡単で，シェルスクリプトは他の用途にも応用可能
            * 終了ステータスを使う点で，他のものと本質的な違いがない
            * コマンドを記述した言語と無関係に，同じ方法で入出力をテスト可能

---

### 準備

1. `plus_stdin`を`plus`に改名しておく$\rightarrow$<span style="color:red">コミットを</span>
    * 注意: テストと無関係です．
2. 次のようなシェルスクリプトを書いて動作確認
    * `plus`と同じ場所に．名前は`test.bash`で．
    ```bash
    #!/bin/bash
    
    seq 5 | ./plus
    ```
    * 実行すると`15`と出力$\rightarrow$<span style="color:red">コミットを</span>
3. とりあえずGitHubにpushしておく
    * <span style="color:red">こまめに！</span>

---

### テストの記述

* 出力を変数に格納
* テストコマンドで正解と比較
    ```bash
    #!/bin/bash
    
    out=$(seq 5 | ./plus)
    
    [ "${out}" = 15 ]
    ```
* 動作確認
    ```bash
    $ ./test.bash 
    $ echo $?
    0
    ```
    * 15を14に変えて`echo $?`で`1`と出ることも確認$\rightarrow$<span style="color:red">コミットを</span>
    * なんで判定に終了ステータスを使うのかは次回判明

---

### さらなる改良


* 改良点
    * 人間にも成否が分かるように/テスト項目を追加可能に
* さきほど習得した関数を利用
    * 前回学んだ著作権やライセンスの設定も
    ```bash
    #!/bin/bash
    # SPDX-FileCopyrightText: 2022 Ryuichi Ueda
    # SPDX-License-Identifier: BSD-3-Clause
    
    ng () {
    	echo NG at Line $1
    	res=1
    }
    
    res=0
    
    ### I/O TEST ###
    out=$(seq 5 | ./plus)
    [ "${out}" = 14 ] || ng ${LINENO}
    
    exit $res
    ```

---

### 動作確認

* 失敗した行と終了ステータスを確認
    ```bash
    ./test.bash
    NG at Line 12
    $ echo $?
    1
    ```
    * 動作確認したらテストコマンドで比較する数を`15`に戻して動作確認
    * <span style="color:red">commit & push</span>

---

### テスト項目の追加

* 不正な入力に対する挙動もテストするとよい
    * さも入力が正しいような出力をしていないか
    * 特定の終了ステータスを返しているかどうか

